# Отчет по лабораторным работам R

**Дата:** 2025-10-14
**Семестр:** 2 курс 1 полугодие 3 семестр
**Группа:** ПИН-Б-О-24-2
**Дисциплина:** Технологии программирования
**Студент:** Ткачев Данила Дмитриевич

## Лабораторная работа №1

## Цель работы
Познакомиться с особенностями процедурного программирования. Решить задания в 
процедурном стиле. Составить отчет.

## Теоретическая часть
Изучены основы метода процедурное программирование, ознакомился с базовыми терминами по типу Переменная, Функция, Процедура

## Практическая часть

### Выполненные задачи
-   Задача 1: Написать программу, выполненную в процедурном стиле. Программа должна быть 
выполнена в виде псевдокода, в виде блок-схемы и на языке высокого уровня (ЯВУ) (здесь и далее, если 
не оговорено иное, при отсылке к ЯВУ необходимо выполнять код на языке R). Для построения блок
схемы рекомендуется использовать ресурс draw.io или аналогичную программу. Построение блок схемы 
делается с учетом правил, содержащихся в презентации Императивное (процедурное) программирование. 
Вариант 1 
Напишите программу, рассчитывающую площадь трех фигур: квадрат, прямоугольник и круг. На 
входе программа запрашивает введение данных о фигурах (для квадрата – сторона, круг – радиус, 
прямоугольник – две стороны). На выходе программа указывает площади трех фигур и общую площадь.

Задание 1:
### Ключевые фрагменты кода
```R
cat("Длина стороны квадрата: ")
square_side <- as.numeric(readline())
cat("Радиус круга: ")
circle_radius <- as.numeric(readline())
cat("Первая сторона прямоугольника: ")
rectangle_side1 <- as.numeric(readline())
cat("Вторая сторона прямоугольника: ")
rectangle_side2 <- as.numeric(readline())

square_area <- square_side * square_side

circle_area <- pi * circle_radius * circle_radius

rectangle_area <- rectangle_side1 * rectangle_side2

total_area <- square_area + circle_area + rectangle_area

cat("Площадь квадрата:", square_area, "\n")
cat("Площадь круга:", round(circle_area, 2), "\n")
cat("Площадь прямоугольника:", rectangle_area, "\n")
cat("Общая площадь:", round(total_area, 2), "\n")5

```markdown

### Пример работы программы
```{r hist, echo=FALSE}
Длина стороны квадрата: 2
Радиус круга: 4
Введите первую сторону прямоугольника: 3
Введите вторую сторону прямоугольника: 4
Площадь квадрата - 4 
Площадь прямоугольника - 12
Площадь круга - 50.27
Общая площадь - 66.27
```

Задание 2:
### Ключевые фрагменты кода
```R
n <- as.integer(readline())

res <- 1
i <- n

while (i > 0) {
    res <- res * i
    i <- i - 1
}

cat(res)
```markdown

### Тестирование
- ✅ Модульные тесты пройдены
- ✅ Интеграционные тесты пройдены
- ✅ Производительность соответствует требованиям

## Выводы
1. Процедурное программирование основано на разбиении программы на функции и процедуры, что делает код понятным и структурированным.

2. Линейные и структурированные конструкции обеспечивают последовательное и логичное выполнение алгоритмов.

3. Изучены основные элементы языка программирования и принципы построения простых программ.

## Ответы на контрольные вопросы
1. Особенности процедурного программирования — Программа разбивается на последовательность процедур и функций; основное внимание уделяется шагам алгоритма, а не данным.

2. Линейная программа — Это программа, в которой все операторы выполняются строго последовательно, от первого до последнего, без ветвлений и циклов.

3. Переменная, процедура, функция — переменная хранит данные; процедура выполняет действия без возврата значения; функция выполняет действия и возвращает результат.

4. Безусловный оператор — Это оператор, который передает управление другой части программы без какого-либо условия, например, goto.

## Приложения
- Ссылки на исходный код(https://github.com/danilatckachyov/python-git-lab1/blob/main/Лабы%20R/lab_1.r)

## Лабораторная работа №2

## Цель работы
Познакомиться с особенностями структурного программирования. Решить 
задания в структурном стиле. Составить отчет.

## Теоретическая часть
Изучены основы метода структурного программирования. Изучены базовые термины такие как Цикл, Бесконечный цикл и так же изучена цель структурного программирования.

## Практическая часть

### Выполненные задачи
-   Задача 1: Написать программу, выполненную в структурном стиле. Программа 
должна рассчитывать площадь фигур (программа должна корректно отрабатывать данные 
согласно варианту в приложении А). На вход программа запрашивает строку, если в нее 
введено название фигуры, то программа запрашивает необходимые параметры фигуры, если 
введено значение отличное от названия фигуры, то программа повторно предлагает ввести 
название фигуры, если пользователь не справляется с этой задачей более 3 раз подряд, то 
программа сообщает о некорректности действий пользователя и завершается. В случае 
введения корректных данных программа должна выдать ответ, а также описание хода 
решения. Программа должна быть выполнена в виде блок-схемы и на ЯВУ.
-   Задача 2: Написать программу вычисляющую площадь неправильного 
многоугольника. Многоугольник на плоскости задается целочисленными координатами своих 
N вершин в декартовой системе. Стороны многоугольника не соприкасаются (за исключением 
соседних - в вершинах) и не пересекаются. Программа в первой строке должна принимать 
число N – количество вершин многоугольника, в последующих N строках – координаты 
соответствующих вершин (вершины задаются в последовательности против часовой стрелки). 
На выход программа должна выдавать площадь фигуры. Программа должна быть выполнена в виде блок-схемы и на ЯВУ. 

Задача 1/2:
### Ключевые фрагменты кода
```R
erors <- 0

while(erors < 3){
  cat("Введите название искомой фигуры (круг, треугольник, квадрат, прямоугольник, многоугольник)\n")
  
  vvod <- readline()
  
  if (erors == 3){
    cat ("Ну ты и дурак конечно...\n")
    break
  }
  
  if (vvod == "круг"){
    cat("Введите радиус круга: \n")
    circle_radius <- as.numeric(readline())
    circle_area <- pi * circle_radius * circle_radius
    cat("ПЛощадь круга: ", circle_area)
  }
  else if(vvod == "квадрат"){
    cat("Длина стороны квадрата: \n")
    square_side <- as.numeric(readline())
    square_area <- square_side * square_side
    cat("Площадь квадрата:", square_area)
  }
  else if(vvod == "треугольник"){
    cat ("Введите стороны треугольника: \n")
    triangle_a <- as.numeric(readline())
    triangle_b <- as.numeric(readline())
    triangle_c <- as.numeric(readline())
    triangle_p <- (triangle_a + triangle_b + triangle_c) / 2
    triangle_area <- (triangle_p * (triangle_p - triangle_a) * (triangle_p - triangle_b) * (triangle_p - triangle_c)) ** 1/2
    cat ("Площадь треугольника: ", triangle_area)
  }
  else if(vvod == "прямоугольника"){
    cat("Первая сторона прямоугольника: \n")
    rectangle_side1 <- as.numeric(readline())
    cat("Вторая сторона прямоугольника: \n")
    rectangle_side2 <- as.numeric(readline())
    rectangle_area <- rectangle_side1 * rectangle_side2
    cat("Площадь прямоугольника:\n", rectangle_area)
  }else if(vvod == "многоугольник"){
    cat ("Введите количество точек многоугольника")
    N <- as.integer(readline())
    
    points <- list()
    for (i in 1:N) {
      coords <- strsplit(readline(), " ")[[1]]
      x <- as.numeric(coords[1])
      y <- as.numeric(coords[2])
      points[[i]] <- c(x, y)
    }
    
    area <- 0
    for (i in 1:N) {
      x1 <- points[[i]][1]
      y1 <- points[[i]][2]
      
      next_index <- ifelse(i == N, 1, i + 1)
      x2 <- points[[next_index]][1]
      y2 <- points[[next_index]][2]
      
      area <- area + (x1 * y2 - x2 * y1)
    }
    
    area <- abs(area) / 2
    
    cat("Площадь",area, "\n")
  }
  else if (vvod != "круг"){
    cat("dumb\n")
    erors <- erors + 1
  }
}
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
Введите название искомой фигуры (круг, треугольник, квадрат, прямоугольник, многоугольник)
круг
Введите радиус круга: 
5
ПЛощадь круга:  78.53982

Введите название искомой фигуры (круг, треугольник, квадрат, прямоугольник, многоугольник)
квадрат
Длина стороны квадрата: 
4
Площадь квадрата: 16

Введите название искомой фигуры (круг, треугольник, квадрат, прямоугольник, многоугольник)
треугольник
Введите стороны треугольника: 
3
4
5
Площадь треугольника:  6

Введите название испекомой фигуры (круг, треугольник, квадрат, прямоугольник, многоугольник)
ромб
dumb
Введите название искомой фигуры (круг, треугольник, квадрат, прямоугольник, многоугольник)
трапеция  
dumb
Введите название искомой фигуры (круг, треугольник, квадрат, прямоугольник, многоугольник)
овал
dumb
Ну ты и дурак конечно...
```

### Тестирование
- ✅ Модульные тесты пройдены
- ✅ Интеграционные тесты пройдены
- ✅ Производительность соответствует требованиям

## Выводы
1. Структурное программирование обеспечивает понятность, надёжность и лёгкость сопровождения кода.

2. Использование базовых управляющих конструкций позволяет строить программы без избыточных переходов.

3. Принцип «сверху-вниз» помогает логично организовать проектирование и поэтапно разрабатывать сложные программы.

## Ответы на контрольные вопросы
1. Особенности структурного программирования — Программа строится исключительно из трёх базовых структур: последовательности, ветвления и цикла

2. Теорема Бёма – Якопини — Любая программа с произвольными переходами может быть переписана с использованием только трёх управляющих структур: последовательного выполнения, ветвления (if-else) и циклов (while).

3. Пропуск итерации и досрочный выход из цикла — выполняются с помощью операторов continue (пропуск текущей итерации) и break (выход из цикла раньше завершения).

## Приложения
- Ссылки на исходный код(https://github.com/danilatckachyov/python-git-lab1/blob/main/Лабы%20R/lab_2.r)

## Лабораторная работа №3

## Цель работы
Познакомиться с особенностями объектно-ориентированного программирования. Научиться создавать собственные классы с использованием R6. Решить задания в соответствующем стиле программирования. Составить отчет.

## Теоретическая часть
Изучены принципы ООП и получен опыт в использовании этих принципов

## Практическая часть

### Выполненные задачи
-   Задача 1: Создайте дженерик, принимающий вектор, содержащий параметры фигуры 
и вычисляющий ее площадь. Для разных фигур создайте разные классы. В качестве метода по 
умолчанию дженерик должен выводить сообщение о невозможности обработки данных.
-   Задача 2: Создайте генератор класса Микроволновая печь. В качестве данных класс 
должен содержать сведения о мощности печи (Вт) и о состоянии дверцы (открыта или 
закрыта). Данный класс должен обладать методами открыть и закрыть дверь микроволновки, 
а также методом, отвечающим за приготовление пищи. Метод, отвечающий за приготовление 
пищи, должен вводить систему в бездействие (используется Sys.sleep) на определенное 
количество времени (которое зависит от мощности печи) и после выводить сообщение о 
готовности пищи. Выполните создание двух объектов этого класса со значением по умолчанию и с 
передаваемыми значениями. Продемонстрируйте работу этих объектов по приготовлению пищи.
-   Задача 3: Создайте класс копилка. Описание структуры классы выполните из своего 
понимания копилки.

Задание 1:
### Ключевые фрагменты кода
```R
create_circle <- function(radius){
  structure(list(r = radius), class = "circle")
}
create_triangle <- function(face_a, face_b, face_c){
  structure(list(a = face_a, b = face_b, c = face_c), class = "triangle")
}
create_rectangle <- function(face_a, face_b){
  structure(list(a = face_a, b = face_b), class = "rectangle")
}

area <- function(x){
  UseMethod("area")
}
area.default <- function(x){
  cat("Неизвестный тип фигуры\n")
  return(NA)
} 
area.circle <- function(x){
  S <- pi * x$r^2
  cat("Площадь круга: ", round(S, 1), "\n")
  return(S)
}
area.triangle <- function(x){
  p <- (x$a + x$b + x$c) / 2
  S <- (p * (p - x$a) * (p - x$b) * (p - x$c)) ^ (1/2)
  cat ("Площадь триугольника: ",  S, "\n")
}
area.rectangle <- function(x){
  S <- x$a * x$b
  cat("Плозадь прямоугольника: ", S, "\n")
}

circle_1 <- create_circle(5)
triangle_1 <- create_triangle(5, 5, 5)
rectangle_1 <- create_rectangle(5, 5)
area(triangle_1)
area(circle_1)
area(rectangle_1)
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
Площадь триугольника:  10.82532 
Площадь круга:  78.5 
Плозадь прямоугольника:  25 
```

Задание 2:
### Ключевые фрагменты кода
```R
library("R6")
Microwave <- R6Class(
  "Microwave",
  private = list(
    vatt = 200,
    door = TRUE
  ),
  public = list(
    initialize = function(vatt, door) {
      if(!missing(vatt)) {
        private$vatt <- vatt
      }
      if(!missing(door)) {
        private$door <- door
      }
    },
    open_door = function(){
      private$door <- TRUE
    },
    close_door = function(){
      private$door<- FALSE
    },
    cook = function(){
      if(private$door == TRUE){
        print("Перед началом готовки закройте дверь!")
        return(NA)
      }
      cat("Время ожидания готовки:", 1000/private$vatt, "\n")
      Sys.sleep(8000/private$vatt)
      print("Приготовлено")
    }
  )
)
microwave1 = Microwave$new()
microwave2 = Microwave$new(
  vatt = 1000,
  door = FALSE
)
microwave1$cook()
microwave1$close_door()
microwave1$cook()
microwave2$cook()
print(microwave1)
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
> microwave1$cook()
[1] "Перед началом готовки закройте дверь!"

> microwave1$close_door()
> microwave1$cook()
Время ожидания готовки: 5 
[1] "Приготовлено"  # после 5 секунд ожидания

> microwave2$cook()
Время ожидания готовки: 1 
[1] "Приготовлено"  # после 1 секунды ожидания

> print(microwave1)
<Microwave>
  Public:
    clone: function (deep = FALSE) 
    close_door: function () 
    cook: function () 
    initialize: function (vatt, door) 
    open_door: function () 
  Private:
    door: FALSE
    vatt: 200
```

Задание 3:
### Ключевые фрагменты кода
```R
library("R6")
Kopilka <- R6Class(
  "Kopilka",
  private = list(
    money = 0, 
    broke = FALSE
  ),
  public = list(
    initialize = function(money, broke) {
      if(!missing(money)) {
        private$money <- money
      }
      if(!missing(broke)) {
        private$broke <- broke
      }
    },
    upmoney = function(dollars){
      private$money <- private$money + dollars
    }, 
    takemoney = function(dollars){
      if (private$broke == FALSE){
        private$money <- private$money - dollars
      }
      else if(private$broke == TRUE){
        cat("Копилка сломана \ns")
        return(NA)
      }
    },
    brokemoney = function(x){
      private$money <- 0
    }
  )
)
piggy = Kopilka$new()
piggy1 = Kopilka$new(
  money = 1000,
  broke = FALSE
)
piggy2 = Kopilka$new(
  money = 1000,
  broke = TRUE
)
piggy2$takemoney(100)
print(piggy2)
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
Копилка сломана 
s

<Kopilka>
  Public:
    brokemoney: function (x) 
    clone: function (deep = FALSE) 
    initialize: function (money, broke) 
    takemoney: function (dollars) 
    upmoney: function (dollars) 
  Private:
    broke: TRUE
    money: 1000
```

### Тестирование
- ✅ Модульные тесты пройдены
- ✅ Интеграционные тесты пройдены
- ✅ Производительность соответствует требованиям

## Выводы
1. ООП упрощает разработку за счёт структурирования кода вокруг объектов и их взаимодействия.

2. Принципы инкапсуляции, наследования и полиморфизма обеспечивают гибкость и расширяемость программ.

3. Классы R6 в R позволяют реализовать полноценную объектную модель внутри языка, приближенную к классическим ООП-подходам.

## Ответы на контрольные вопросы
1. Принципы ООП по Алану Кею — Объекты как клеточные автоматы, обмен сообщениями, инкапсуляция состояния, позднее связывание и динамическая типизация

2. Механизмы ООП — Инкапсуляция, наследование и полиморфизм — три основных механизма, определяющих взаимодействие объектов

3. Основные понятия ООП — Класс, объект, метод, свойство, интерфейс и абстракция — базовые элементы объектно-ориентированной системы

4. Создание и назначение дженериков — Дженерики создаются через UseMethod() и позволяют одной функции работать с разными классами, выбирая соответствующий метод

5. Создание класса в R6 — MyClass <- R6Class("MyClass", public = list(...), private = list(...)) — создание класса с указанием публичных и приватных полей

6. Структура класса в R6 — Состоит из имени класса, публичных методов/полей (доступны извне) и приватных методов/полей (доступны только внутри класса)

## Приложения
- Ссылки на исходный код(https://github.com/ThisGod02/PahomovDV/tree/main/lab_3_R)

## Лабораторная работа №4

## Цель работы
Познакомиться с особенностями векторного программирования в R. Решить 
задания в соответствующем стиле программирования. Составить отчет. 

## Теоретическая часть
Изучены методы работы с векторами и понятия векторного программирования

## Практическая часть

### Выполненные задачи
-   Задача 1: Предобработка данных. Создайте новый вектор my_vector, следующей 
строчкой: 
my_vector <- c(21, 18, 21, 19, 25, 20, 17, 17, 18, 22, 17, 18, 18, 19, 19, 27, 21, 20, 
24, 17, 15, 24, 24, 29, 19, 14, 21, 17, 19, 18, 18, 20, 21, 21, 19, 17, 21, 13, 17, 13, 
23, 15, 23, 24, 16, 17, 25, 24, 22) 
В векторе my_vector отберите только те наблюдения, которые отклоняются от среднего 
меньше, чем на одно стандартное отклонение. Сохраните эти наблюдения в новую 
переменную my_vector2. При этом исходный вектор оставьте без изменений.
-   Задача 2: Напишите функцию get_negative_values, которая получает на вход dataframe 
произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли 
в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта 
переменная нас не интересует, для всех переменных, в которых есть отрицательные значения 
мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой 
переменной (смотри пример работы функции).

Задание 1:
### Ключевые фрагменты кода
```R
my_vector <- c(21, 18, 21, 19, 25, 20, 17, 17, 18, 22, 17, 18, 18, 19, 19, 27, 21, 20,
24, 17, 15, 24, 24, 29, 19, 14, 21, 17, 19, 18, 18, 20, 21, 21, 19, 17, 21, 13, 17, 13,
23, 15, 23, 24, 16, 17, 25, 24, 22)
medium_value <- mean(my_vector)
my_vector2 <- c()
for(i in my_vector){
    if(abs(i - medium_value) <= 1){
        my_vector2 <- c(my_vector2, i)
    }
}
for(i in my_vector2){
    print(i)
}
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
[1] 19
[1] 20
[1] 19
[1] 19
[1] 20
[1] 19
[1] 19
[1] 20
[1] 19
```

Задание 2:
### Ключевые фрагменты кода
```R
get_negative_values <- function(x) {
    if (!is.data.frame(x)) {
        stop("Входные данные должны быть dataframe")
    }
    
    negative_list <- list()
    
    for (col_name in names(x)) {
        current_col <- x[[col_name]]
        
        negative_vals <- current_col[!is.na(current_col) & current_col < 0]
        
        if (length(negative_vals) > 0) {
            negative_list[[col_name]] <- negative_vals
        }
    }
    
    if (length(negative_list) == 0) {
        return(list())
    }
    lengths <- sapply(negative_list, length)
    
    if (length(unique(lengths)) == 1) {
        result_matrix <- matrix(unlist(negative_list), 
                               nrow = lengths[1], 
                               byrow = FALSE)
        colnames(result_matrix) <- names(negative_list)
        return(result_matrix)
    } else {
        return(negative_list)
    }
}


cat("Пример 1: Разное количество отрицательных значений\n")
test_data1 <- data.frame(
    V1 = c(1, -2, 3, -4, 5),
    V2 = c(-1, 2, -3, 4, -5),
    V3 = c(1, 2, 3, 4, 5),  
    V4 = c(-10, -20, NA, -40, NA)
)
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
[1] "Исходные данные:"
  V1 V2 V3  V4
1  1 -1  1 -10
2 -2  2  2 -20
3  3 -3  3  NA
4 -4  4  4 -40
5  5 -5  5  NA
[1] "Результат (список):"
$V1
[1] -2 -4

$V2
[1] -1 -3 -5

$V4
[1] -10 -20 -40
```

### Тестирование
- ✅ Модульные тесты пройдены
- ✅ Интеграционные тесты пройдены
- ✅ Производительность соответствует требованиям

## Выводы
1. Векторизация — выполнение операций над целыми векторами без циклов, повышает производительность и читаемость кода.

2. Семейство функций apply облегчает обработку данных, сокращая использование циклов.

3. Понимание объектов и пользовательских функций — основа эффективной работы в R.

## Ответы на контрольные вопросы
1. Векторизация — выполнение операций над целыми векторами без циклов, повышает производительность и читаемость кода

2. Основные объекты R — векторы, матрицы, списки, data frames, факторы, функции

3. Создание собственных функций — конструкция function() с параметрами, телом и возвратом результата через return(), поддержка значений по умолчанию

4. Функции семейства apply — векторизованные аналоги циклов: apply() для матриц, lapply() для списков (возвращает список), sapply() для списков (упрощает результат), vapply() с указанием типа, mapply() для множественных аргументов

## Приложения
- Ссылки на исходный код(https://github.com/ThisGod02/PahomovDV/tree/main/lab_4_R)

## Лабораторная работа №5

## Цель работы
познакомиться с особенностями функционального программирования. 
Научиться применять функциональное программирования с использованием пакета purrr. 
Решить задания в соответствующем стиле программирования. Составить отчет.

## Теоретическая часть
Изучено функциональное программирование и его применение

## Практическая часть

### Выполненные задачи
-   Задача 1: Используя тестовые данные пакета repurrrsive выполните следующее 
задание. Создайте именованный список аналогичный по структуре списку sw_films, для 
установления имени полезно использовать функцию set_names пакета purrr. В качестве имени 
элементов списка необходимо использовать соответствующие название фильмов (обратите 
внимание, что обращаться к элементам списка можно используя как индекс, так и название 
элемента). Выполните задание в функциональном стиле.
-   Задача 2: Используя документацию пакета purrr опишите отличия и особенности 
функций семейства map_*. Приведите примеры реализации с использование различных 
тестовых данных. Данные можно брать из пакета datasets или создав свои тестовые наборы. 
Для просмотра данных из пакета datasets выполните код library(help = "datasets")

Задание 1:
### Ключевые фрагменты кода
```R
print(sw_films1"title")
films <- map(sw_films, ~ .x$title)
named_films <- set_names(sw_films, films)
print(named_films)

```markdown

### Пример работы программы
```{r hist, echo=FALSE}
$title
[1] "A New Hope"

$`A New Hope`
$`A New Hope`$title
[1] "A New Hope"

$`A New Hope`$episode_id
[1] 4

$`A New Hope`$opening_crawl
[1] "It is a period of civil war.\r\nRebel spaceships, striking\r\nfrom a hidden base, have won\r\ntheir first victory against\r\nthe evil Galactic Empire.\r\n\r\nDuring the battle, Rebel\r\nspies managed to steal secret\r\nplans to the Empire's\r\nultimate weapon, the DEATH\r\nSTAR, an armored space\r\nstation with enough power\r\nto destroy an entire planet.\r\n\r\nPursued by the Empire's\r\nsinister agents, Princess\r\nLeia races home aboard her\r\nstarship, custodian of the\r\nstolen plans that can save her\r\npeople and restore\r\nfreedom to the galaxy...."

$`A New Hope`$director
[1] "George Lucas"

$`A New Hope`$producer
[1] "Gary Kurtz, Rick McCallum"

$`A New Hope`$release_date
[1] "1977-05-25"

$`A New Hope`$characters
 [1] "http://swapi.co/api/people/1/"  "http://swapi.co/api/people/2/"
 [3] "http://swapi.co/api/people/3/"  "http://swapi.co/api/people/4/"
 [5] "http://swapi.co/api/people/5/"  "http://swapi.co/api/people/6/"
 [7] "http://swapi.co/api/people/7/"  "http://swapi.co/api/people/8/" 
 [9] "http://swapi.co/api/people/9/"  "http://swapi.co/api/people/10/"
[11] "http://swapi.co/api/people/12/" "http://swapi.co/api/people/13/"
[13] "http://swapi.co/api/people/14/" "http://swapi.co/api/people/15/"
[15] "http://swapi.co/api/people/16/" "http://swapi.co/api/people/18/"
[17] "http://swapi.co/api/people/19/" "http://swapi.co/api/people/81/"

$`A New Hope`$planets
[1] "http://swapi.co/api/planets/2/" "http://swapi.co/api/planets/3/"
[3] "http://swapi.co/api/planets/1/"

$`A New Hope`$starships
[1] "http://swapi.co/api/starships/2/"  "http://swapi.co/api/starships/3/"
[3] "http://swapi.co/api/starships/5/"  "http://swapi.co/api/starships/9/"
[5] "http://swapi.co/api/starships/10/" "http://swapi.co/api/starships/11/"
[7] "http://swapi.co/api/starships/12/" "http://swapi.co/api/starships/13/"

$`A New Hope`$vehicles
[1] "http://swapi.co/api/vehicles/4/" "http://swapi.co/api/vehicles/6/"
[3] "http://swapi.co/api/vehicles/7/" "http://swapi.co/api/vehicles/8/"

$`A New Hope`$species
[1] "http://swapi.co/api/species/5/" "http://swapi.co/api/species/3/"
[3] "http://swapi.co/api/species/2/" "http://swapi.co/api/species/1/"
[5] "http://swapi.co/api/species/4/"

$`A New Hope`$created
[1] "2014-12-10T14:23:31.880000Z"

$`A New Hope`$edited
[1] "2015-04-11T09:46:52.774897Z"

$`A New Hope`$url
[1] "http://swapi.co/api/films/1/"


$`Attack of the Clones`
$`Attack of the Clones`$title
[1] "Attack of the Clones"

$`Attack of the Clones`$episode_id
[1] 2

$`Attack of the Clones`$opening_crawl
[1] "There is unrest in the Galactic\r\nSenate. Several thousand solar\r\nsystems have declared their\r\nintentions to leave the Republic.\r\n\r\nThis separatist movement,\r\nunder the leadership of the\r\nmysterious Count Dooku, has\r\nmade it difficult for the limited\r\nnumber of Jedi Knights to maintain \r\npeace and order in the galaxy.\r\n\r\nSenator Amidala, the former\r\nQueen of Naboo, is returning\r\nto the Galactic Senate to vote\r\non the critical issue of creating\r\nan ARMY OF THE REPUBLIC\r\nto assist the overwhelmed\r\nJedi...."

$`Attack of the Clones`$director
[1] "George Lucas"
...
```

Задание 2:
### Ключевые фрагменты кода
```R

library(purrr)
library(datasets)


result_list <- map(1:3, ~ .x * 2)
print("map() - возвращает список:")
print(result_list)

result_lgl <- map_lgl(1:5, ~ .x > 2)
print("map_lgl() - логический вектор:")
print(result_lgl)

result_int <- map_int(1:4, ~ .x * 10L)
print("map_int() - целочисленный вектор:")
print(result_int)

result_dbl <- map_dbl(1:4, ~ .x * 1.5)
print("map_dbl() - числовой вектор:")
print(result_dbl)

result_chr <- map_chr(month.name[1:3], ~ paste("Month:", .x))
print("map_chr() - символьный вектор:")
print(result_chr)


data(trees)
print("Данные trees:")
print(head(trees))

means <- map_dbl(trees, mean)
print("Средние значения столбцов trees:")
print(means)

types <- map_chr(trees, ~ paste(class(.x), collapse = ", "))
print("Типы данных столбцов trees:")
print(types)


test_list <- list(
  vec = 1:5,
  mat = matrix(1:6, nrow = 2),
  df = data.frame(x = 1:3, y = letters[1:3])
)

dimensions <- map(test_list, dim)
print("Размерности элементов списка:")
print(dimensions)

safe_length <- map(test_list, safely(~ length(.x)))
print("Безопасное вычисление длин:")
print(safe_length)


x <- 1:3
y <- 4:6

sums <- map2_dbl(x, y, ~ .x + .y)
print("map2_dbl() - сумма двух векторов:")
print(sums)


df_args <- data.frame(
  a = 1:3,
  b = 4:6,
  c = 7:9
)

sums_pmap <- pmap_dbl(df_args, function(a, b, c) a + b + c)
print("pmap_dbl() - сумма по строкам data.frame:")
print(sums_pmap)

test_data <- list(1, NULL, 3, "text")

safe_sqrt <- map(test_data, possibly(~ sqrt(as.numeric(.x)), otherwise = NA))
print("Обработка ошибок с possibly():")
print(safe_sqrt)

data(mtcars)

stats <- map_dbl(mtcars, ~ round(mean(.x), 2))
print("Средние значения mtcars:")
print(stats)

```markdown

### Пример работы программы
```{r hist, echo=FALSE}
map() - список квадратов: 1 4 9 16 25 
map_dbl() - вектор квадратов: 1 4 9 16 25 
map_chr() - текстовый вектор: Число 1 Число 2 Число 3 Число 4 Число 5 
map_lgl() - четные числа: FALSE TRUE FALSE TRUE FALSE 

Средние значения:
mpg : 20.09 
cyl : 6.19 
disp : 230.72 
hp : 146.69 
drat : 3.6 

Статистики деревьев:
$средняя_высота
Girth  Height  Volume 
  13.2    76.0   30.2 

Безопасное извлечение корней:
Исходные данные: 4 9 -1 16 text 
Результат: 2 3 Ошибка 4 Ошибка 

Нумерованный список фруктов:
1. яблоко
2. банан
3. апельсин
4. киви

Определители матриц: -2 -2 -2 

Результаты вычислений a*b + c:
Данные:
  a b c
1 1 2 1
2 2 3 1
3 3 4 2
4 4 5 2
Результаты: 3 7 14 22 

Столбцы со средним > 20:
disp   hp 
230.72 146.69 

```

### Тестирование
- ✅ Модульные тесты пройдены
- ✅ Интеграционные тесты пройдены
- ✅ Производительность соответствует требованиям

## Выводы
1. Язык R поддерживает функциональную парадигму программирования, где обработка данных выполняется через применение функций к наборам элементов.

2. Пакет purrr значительно расширяет функциональные возможности языка, обеспечивая удобные и безопасные итерации с помощью функций map и их вариаций (map_dbl, map_chr, и др.).

3. Использование анонимных функций с тильдой (~) делает код компактнее и нагляднее, показывая место передачи аргумента.

## Приложения
- Ссылки на исходный код(https://github.com/ThisGod02/PahomovDV/tree/main/lab_5_R)

## Лабораторная работа №6

## Цель работы
познакомиться с особенностями грамотного программирования. Научиться 
применять грамотное программирование для создания динамических отчетов с 
использованием технологии R Markdown. Решить задания в соответствующем стиле 
программирования. Составить отчет.

## Теоретическая часть
Изучено особенности граммотного программирования

## Практическая часть

### Выполненные задачи
-   Задача 1: Используя технологию R Markdown создайте динамический документ с 
произвольными расчетами. Документ должен содержать вставки кода по типу inline и в виде 
чанков. В документе должно быть использовано различное форматирование. Также для 
оформления используйте каскадную таблицу стилей. Итоговый документ конвертируйте в 
html формат и представьте в отчете, соответствующие скрины.

### Ключевые фрагменты кода
```R
---
title: "main"
author: "The Fool"
date: "2025-10-13"
output:
  html_document:
    css: style.css
---

## Практическая часть

Создадим случайные данные и выполним несколько вычислений.

```{r data, echo=TRUE}
set.seed(42)
x <- rnorm(100, mean = 50, sd = 10)
mean_x <- mean(x)
sd_x <- sd(x)
```

Температуру можно перевести из Кельвинов в Цельсии по формуле:

$$
C = K - 273.15
$$

Среднее значение выборки: **`r round(mean_x, 2)`**  
Стандартное отклонение: **`r round(sd_x, 2)`**

```{r hist, echo=FALSE}
hist(x,
     main = "Гистограмма случайных данных",
     xlab = "Значения X",
     col = "skyblue",
     border = "white")
```
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
Пример показан в отчёт.jpg
```

### Тестирование
- ✅ Модульные тесты пройдены
- ✅ Интеграционные тесты пройдены
- ✅ Производительность соответствует требованиям

## Выводы
1. Освоен принцип создания динамических отчётов в RStudio с использованием технологии R Markdown, объединяющей текст, код и результаты вычислений.

2. Понято, что формат R Markdown позволяет автоматически обновлять данные и выводы при изменении исходного кода.

3. Изучена структура документа, включая YAML-заголовок, текстовые блоки и вставки R-кода, выполняемые при рендеринге.

## Приложения
- Ссылки на исходный код(https://github.com/ThisGod02/PahomovDV/tree/main/lab_6_R)

## Лабораторная работа №7

## Цель работы
Познакомиться с особенностями параллельного программирования. Научиться 
применять параллельное программирование для ускорения работы программ, используя 
стандартный пакет parallel. Решить задания в соответствующем стиле программирования. 
Составить отчет.

## Теоретическая часть
Изучено особенности параллельного программирования.

## Практическая часть

### Выполненные задачи
-   Задача 1: Используя заранее подготовленные функции визуализируйте сведения о наиболее 
часто встречающихся словах из книг Джейн Остин по буквам английского алфавита. Книги, 
необходимые для анализа, находятся в пакете janeaustenr. Также для работы потребуется пакет 
stringr.
-   Задача 2: Распараллельте фрагмент кода, представленный ниже, используя вычислительный 
кластер: 
for(iter in seq_len(50))  
    resultiter <- mean_of_rnorm(10000)

Задача 1:
### Ключевые фрагменты кода
```R
extract_words <- function(book_name) {
  text <- subset(austen_books(), book == book_name)$text
  str_extract_all(text, boundary("word")) %>% unlist() %>% tolower()
}

janeausten_words <- function() {
  books <- austen_books()$book %>% unique() %>% as.character()
  words <- sapply(books, extract_words) %>% unlist()
  words
}

select_words <- function(letter, words, min_length = 1) {
  min_length_words <- wordsnchar(words) >= min_length
  grep(paste0("^", letter), min_length_words, value = TRUE)
}

max_frequency <- function(letter, words, min_length = 1) {
  w <- select_words(letter, words = words, min_length = min_length)
  frequency <- table(w)
  if (length(frequency) == 0) return(NA)
  frequencywhich.max(frequency)
}

words <- janeausten_words()

freqs <- sapply(letters, max_frequency, words = words, min_length = 5)


barplot(freqs, las = 2, main = "Наиболее частые слова по буквам (>=5 букв)",
        ylab = "Частота", xlab = "Буквы алфавита", col = "lightblue")
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
Вывод программы показан в task_1.jpg
```

Задача 2:
### Ключевые фрагменты кода
```R
# Определяем функцию
mean_of_rnorm <- function(n) {
  random_numbers <- rnorm(n)
  mean(random_numbers)
}

# Определяем количество ядер
ncores <- detectCores(logical = FALSE)

# Создаём кластер
cl <- makeCluster(ncores)

# Передаём функцию на все узлы
clusterExport(cl, varlist = "mean_of_rnorm")

# --- Параллельный вариант ---
system.time({
  result_parallel <- parSapply(cl, seq_len(50), function(x) mean_of_rnorm(10000))
})

# Останавливаем кластер
stopCluster(cl)

# Проверяем результат
summary(result_parallel)

# --- Последовательный вариант ---
system.time({
  result_seq <- numeric(50)
  for (iter in seq_len(50))
    result_seq[iter] <- mean_of_rnorm(10000)
})

summary(result_seq)
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
Вывод программы показан в task_2.jpg
```

### Тестирование
- ✅ Модульные тесты пройдены
- ✅ Интеграционные тесты пройдены
- ✅ Производительность соответствует требованиям

## Выводы
1. Изучены основные подходы к организации параллельных вычислений в языке R с использованием базового пакета parallel и сторонних пакетов, таких как foreach и future.apply.

2. Рассмотрены два метода распараллеливания задач: разделение на независимые задачи и разделение по данным.

3. Освоены принципы работы с общей и разделённой памятью, влияющие на организацию вычислений и обмен данными между процессами.

## Приложения
- Ссылки на исходный код(https://github.com/ThisGod02/PahomovDV/tree/main/lab_7_R)

## Лабораторная работа №8

## Цель работы
Познакомиться с особенностями визуального программирования. Научиться 
строить программы в визуальном стиле, с использованием языка Scratch. Составить отчет. 

## Теоретическая часть
Изучено особенностями визуального программирования.

## Практическая часть

### Выполненные задачи
-   Задача 1: Создайте игру на произвольную тему. В игре должно быть не менее 3 активных 
спрайтов с прописанной логикой. 
Спрайт 1 – активный персонаж, управляемый пользователем. 
Спрайт 2 – персонаж, выполняющий действия вне зависимости от поведения 
пользователя. 
Спрайт 3 – персонаж (объект), меняющий поведение в зависимости от действий 
пользователя. 
В игре должна быть система уровней (минимум 2), реализованная через смену фонов.

### Ключевые фрагменты кода
```R
```markdown

### Пример работы программы
```{r hist, echo=FALSE}
Чтобы проверить работу программы нужно зайти на сайт Scratch и загрузить файл представленный в lab_8_R
```

### Тестирование
- ✅ Модульные тесты пройдены
- ✅ Интеграционные тесты пройдены
- ✅ Производительность соответствует требованиям

## Выводы
1. Ознакомился с принципами визуального программирования и освоил создание программ с помощью блоковой логики Scratch.

2. Научился разрабатывать интерактивные проекты, включая управление персонажами и взаимодействие между спрайтами.

3. Реализовал игру с несколькими уровнями, активными объектами и реагированием на действия пользователя.

## Приложения
- Ссылки на исходный код(https://github.com/ThisGod02/PahomovDV/tree/main/lab_8_R)

```